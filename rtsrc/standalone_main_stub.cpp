//
// This is a 'stub' that contains the main function, to actually call into the main Wren function.
// This is only necessary for standalone Wren programmes - when embedding Wren, you're the one writing
// the main() function.
//
// Created by znix on 21/07/22.
//

#ifdef _WIN32
#define GEN_ENTRY_ABI __declspec(dllimport)
#endif

#include "GenEntry_ABI.h"
#include "WrenRuntime.h"
#include "common/common.h"

#include <stdio.h>
#include <stdlib.h>

typedef void *(*wren_main_func_t)();

#ifdef _WIN32

extern "C" {
// This variable will get overwritten by tinylink, our custom tiny
// link-editor, to point to the real module start.
DLL_EXPORT wren_main_func_t wrenStandaloneMainModule = nullptr;

// This is exported by the random module built into the runtime
GEN_ENTRY_ABI void *random_get_globals();
};

// Force the compiler to import all the symbols the generated Wren
// modules need, as tinylink can't generate imports itself - it can
// merely use the addresses of those we've already caused.
void *linkerFuncPtrs[] = {
    (void *)wren_virtual_method_lookup,
    (void *)wren_super_method_lookup,
    (void *)wren_init_string_literal,
    (void *)wren_register_signatures_table,
    (void *)wren_init_class,
    (void *)wren_alloc_obj,
    (void *)wren_alloc_foreign_obj,
    (void *)wren_class_get_field_offset,
    (void *)wren_register_closure,
    (void *)wren_create_closure,
    (void *)wren_get_closure_upvalue_pack,
    (void *)wren_alloc_upvalue_storage,
    (void *)wren_unref_upvalue_storage,
    (void *)wren_get_bool_value,
    (void *)wren_get_core_class_value,
    (void *)wren_import_module,
    (void *)wren_get_module_global,
    (void *)wren_call_foreign_method,

    // We also need any bundled Wren modules
    (void *)random_get_globals,
};

#else

// Generated by the QBE backend when a module is marked as main
extern "C" wren_main_func_t wrenStandaloneMainModule;

// Zero it, and let this definition be replaced when we link something else in
__attribute__((weak)) wren_main_func_t wrenStandaloneMainModule = nullptr;

#endif

static void lastFibreExitHandler(const char *errorMessage) {
	if (errorMessage) {
		fputs(errorMessage, stderr);
		exit(1);
	}
	exit(0);
}

static void writeImpl(const char *message, int length) {
	// Don't use the length which then prevents us from writing nulls, this
	// mimics the Wren test runner.
	// TODO figure out a nicer solution.
	printf("%s", message);
}

int main(int argc, char **argv) {
	WrenRuntime::Initialise();

	WrenRuntime::Instance().SetWriteHandler(writeImpl);

	// Set a noop handler for the last fibre exiting. Since there isn't an application
	// embedding Wren here, we don't care if we end on a useless stack.
	WrenRuntime::Instance().SetLastFibreExitHandler(lastFibreExitHandler);

	// Initialise and run the main module
	WrenRuntime::Instance().GetOrInitModuleCaught((void *)wrenStandaloneMainModule);

	return 0;
}
